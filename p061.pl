
#
# Problem 61:
#
# Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers
# are all figurate (polygonal) numbers and are generated by the following
# formula:
#
#        Triangle         P3,n=n(n+1)/2       1, 3, 6, 10, 15, ...
#        Square           P4,n=n**2           1, 4, 9, 16, 25, ...
#        Pentagonal       P5,n=n(3n-1)/2      1, 5, 12, 22, 35, ...
#        Hexagonal        P6,n=n(2n-1)        1, 6, 15, 28, 45, ...
#        Heptagonal       P7,n=n(5n-3)/2      1, 7, 18, 34, 55, ...
#        Octagonal        P8,n=n(3n-2)        1, 8, 21, 40, 65, ...
# 
# The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
# interesting properties.
# 
#    1. The set is cyclic, in that the last two digits of each number is the
#    first two digits of the next number (including the last number with the
#    first).
#    2. Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and
#    pentagonal (P5,44=2882), is represented by a different number in the set.
#    3. This is the only set of 4-digit numbers with this property.
# 
# Find the sum of the only ordered set of six cyclic 4-digit numbers for which
# each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and
# octagonal, is represented by a different number in the set.
#

# This is the number of elements we are looking for.
$size = 6;

# These will hold the polygonal numbers based on the two starting digits.
%s = ( );

# Iterate through the polygonal number functions.
for my $f (3 .. $size + 2) {
	# Iterate through the polygonal number values for this function.
	for (my $n = 1, my $v = P($f, 1); $v <= 9999; ++$n, $v = P($f, $n)) {
		# Skip values less than 1000 (less than 4 digits).
		next if $v < 1000;

		# Get the start and end keys.
		my $sk = int($v / 100);

		# Add the value to the start and end hash.
		$s{$sk} = exists($s{$sk}) ? "$s{$sk},$f:$v" : "$f:$v";
	}
}

# Iterate over all the keys.
#for my $key (sort(keys(%s))) {
for my $key (81 .. 81) {
	# Get the matches for this key.
	my @matches = build_chain($key, $key, $size, ( ));

	# Print the matches.
	for $match (@matches) {
		# Break out the parts.
		@parts = split(/,/, $match);

		# Calculate the sum.
		$sum = 0;
		$sum += substr($_, 2, 4) for (@parts);

		# Print the result.
		print "Found: $sum ($match)\n";
	}
}

# This is used to build the chain of matching values.
sub build_chain {
	# Get the key for the chain.
	my $key = shift;

	# Get the required ending for the chain.
	my $end = shift;

	# Get the length of the chain to build.
	my $len = shift;

	# Get the functions already used.
	my @used_fns = @_;

	# This will hold the matching elements.
	my @matches = ( );

	# Get the value list for the requested key.
	my $value_list = $s{$key};

	# Iterate over the available values.
	for $value (split(/,/, $value_list)) {
		# Parse the value into the function and number.
		my ($function, $num) = split(/:/, $value);

		# Make sure the function has not already been used.
		$fn_used = ':' . join(':', @used_fns) . ':';
		next if ($fn_used =~ /.*:$function:.*/);

		# Determine what to do based on the length.
		if ($len == 1) {
			# Add the match to the list if it is the last one needed, and
			# if the required ending matches.
			push(@matches, $value) if ($end == $num % 100);
		} else {
			# Get the next key.
			my $next_key = $num % 100;

			# Create a used functions list.
			my @new_used_fns = ( );
			push(@new_used_fns, @used_fns, $function);

			# Retrieve the sub-matches.
			my @sub_matches = build_chain($next_key, $end, $len - 1, @new_used_fns);

			# Iterate through the sub-matches.
			for my $sub_match (@sub_matches) {
				# Add the sub-match to the list.
				push(@matches, "$value,$sub_match");
			}
		}
	}

	# Return the matching values.
	return @matches;
}


# This is used to retrieve a polygonal number.
sub P {
	# Get the function to use.
	my $f = shift;

	# Get the n value.
	my $n = shift;

	return P3($n) if $f == 3;
	return P4($n) if $f == 4;
	return P5($n) if $f == 5;
	return P6($n) if $f == 6;
	return P7($n) if $f == 7;
	return P8($n) if $f == 8;
}

# This is used to retrieve a triangle number.
sub P3 {
	# Get the parameter.
	my $n = shift;

	# Return the value.
	return $n * ($n + 1) / 2;
}

# This is used to retrieve a square number.
sub P4 {
	# Get the parameter.
	my $n = shift;

	# Return the value.
	return $n * $n;
}

# This is used to retrieve a pentagonal number.
sub P5 {
	# Get the parameter.
	my $n = shift;

	# Return the value.
	return $n * (3 * $n - 1) / 2;
}

# This is used to retrieve a hexagonal number.
sub P6 {
	# Get the parameter.
	my $n = shift;

	# Return the value.
	return $n * (2 * $n - 1);
}

# This is used to retrieve a heptagonal number.
sub P7 {
	# Get the parameter.
	my $n = shift;

	# Return the value.
	return $n * (5 * $n - 3) / 2;
}

# This is used to retrieve a octagonal number.
sub P8 {
	# Get the parameter.
	my $n = shift;

	# Return the value.
	return $n * (3 * $n - 2);
}

